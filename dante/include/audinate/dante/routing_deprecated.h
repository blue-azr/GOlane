/*
 * File     : dante/routing_deprecated.h
 * Created  : October 2019
 * Author   : Andrew White
 * Synopsis : Dante Routing API: deprecated types and functions
 *
 * Copyright � 2024 Audinate Pty Ltd ACN 120 828 006 (Audinate). All rights reserved.
 *
 *
 * 1.	Subject to the terms and conditions of this Licence, Audinate hereby grants you a worldwide, non-exclusive,
 *        no-charge, royalty free licence to copy, modify, merge, publish, redistribute, sublicense, and/or sell the
 *        Software, provided always that the following conditions are met:
 *        1.1.	the Software must accompany, or be incorporated in a licensed Audinate product, solution or offering
 *                or be used in a product, solution or offering which requires the use of another licensed Audinate
 *                product, solution or offering. The Software is not for use as a standalone product without any
 *                reference to Audinate's products;
 *        1.2.	the Software is provided as part of example code and as guidance material only without any warranty
 *                or expectation of performance, compatibility, support, updates or security; and
 *        1.3.	the above copyright notice and this License must be included in all copies or substantial portions
 *                of the Software, and all derivative works of the Software, unless the copies or derivative works are
 *                solely in the form of machine-executable object code generated by the source language processor.
 *
 * 2.	TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 *        PURPOSE AND NONINFRINGEMENT.
 *
 * 3.	TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL AUDINATE BE LIABLE ON ANY LEGAL THEORY
 *        (INCLUDING, WITHOUT LIMITATION, IN AN ACTION FOR BREACH OF CONTRACT, NEGLIGENCE OR OTHERWISE) FOR ANY CLAIM,
 *        LOSS, DAMAGES OR OTHER LIABILITY HOWSOEVER INCURRED.  WITHOUT LIMITING THE SCOPE OF THE PREVIOUS SENTENCE THE
 *        EXCLUSION OF LIABILITY SHALL INCLUDE: LOSS OF PRODUCTION OR OPERATION TIME, LOSS, DAMAGE OR CORRUPTION OF
 *        DATA OR RECORDS; OR LOSS OF ANTICIPATED SAVINGS, OPPORTUNITY, REVENUE, PROFIT OR GOODWILL, OR OTHER ECONOMIC
 *        LOSS; OR ANY SPECIAL, INCIDENTAL, INDIRECT, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES, ARISING OUT OF OR
 *        IN CONNECTION WITH THIS AGREEMENT, ACCESS OF THE SOFTWARE OR ANY OTHER DEALINGS WITH THE SOFTWARE, EVEN IF
 *        AUDINATE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH CLAIM, LOSS, DAMAGES OR OTHER LIABILITY.
 *
 * 4.	APPLICABLE LEGISLATION SUCH AS THE AUSTRALIAN CONSUMER LAW MAY APPLY REPRESENTATIONS, WARRANTIES, OR CONDITIONS,
 *        OR IMPOSE OBLIGATIONS OR LIABILITY ON AUDINATE THAT CANNOT BE EXCLUDED, RESTRICTED OR MODIFIED TO THE FULL
 *        EXTENT SET OUT IN THE EXPRESS TERMS OF THIS CLAUSE ABOVE "CONSUMER GUARANTEES".	 TO THE EXTENT THAT SUCH CONSUMER
 *        GUARANTEES CONTINUE TO APPLY, THEN TO THE FULL EXTENT PERMITTED BY THE APPLICABLE LEGISLATION, THE LIABILITY OF
 *        AUDINATE UNDER THE RELEVANT CONSUMER GUARANTEE IS LIMITED (WHERE PERMITTED AT AUDINATE'S OPTION) TO ONE OF THE
 *        FOLLOWING REMEDIES OR SUBSTANTIALLY EQUIVALENT REMEDIES:
 *        4.1.	THE REPLACEMENT OF THE SOFTWARE, THE SUPPLY OF EQUIVALENT SOFTWARE, OR SUPPLYING RELEVANT SERVICES AGAIN;
 *        4.2.	THE REPAIR OF THE SOFTWARE;
 *        4.3.	THE PAYMENT OF THE COST OF REPLACING THE SOFTWARE, OF ACQUIRING EQUIVALENT SOFTWARE, HAVING THE RELEVANT
 *                SERVICES SUPPLIED AGAIN, OR HAVING THE SOFTWARE REPAIRED.
 *
 * 5.	This License does not grant any permissions or rights to use the trade marks (whether registered or unregistered),
 *        the trade names, or product names of Audinate.
 *
 * 6.	If you choose to redistribute or sell the Software you may elect to offer support, maintenance, warranties,
 *        indemnities or other liability obligations or rights consistent with this License. However, you may only act on
 *        your own behalf and must not bind Audinate. You agree to indemnify and hold harmless Audinate, and its affiliates
 *        from any liability claimed or incurred by reason of your offering or accepting any additional warranty or additional
 *        liability.
 */

/**
 * @file routing_deprecated.h
 *
 * Support for deprecated Dante routing API functions
 */

#ifndef _DANTE_ROUTING_DEPRECATED_H
#define _DANTE_ROUTING_DEPRECATED_H

#ifndef DAPI_FLAT_INCLUDE
#include "dante/routing.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------
// Old-style TX label interface (channels)
//----------------------------------------------------------

/**
 * Get the canonical name of the given TX channel. A transmit channel's
 * canonical name is fixed and will not change.
 *
 * @param tx the transmit channel
 *
 * @returns the name of the given channel
 *
 * @deprecated Replace concept of 'canonical name' with 'default name' for
 * new style devices.  Difference is that old style devices will advertise
 * the 'canonical' name, but new style devices will not advertise default
 * name if dr_txchannel_set_name() has been successfully called.
 */
AUD_INLINE const char *
dr_txchannel_get_canonical_name
(
	const dr_txchannel_t * tx
) {
	return dr_txchannel_get_default_name(tx);
}

/**
 * Get all the labels for a given txchannel and store as many as possible
 * in the array provided. If the array is longer than or equal to the
 * number of labels, 'len' contains the number of channels and the
 * labels are all stored in the array. If there are more channel labels
 * than can fit in the array, the function fills the array up to the
 * length specified and 'len' is set to the total number of labels.
 *
 * The canonical name is not returned by this call.
 *
 * @param tx the channel whose label's are to be obtained
 * @param len on input, the length of the 'labels' array; on output,
 *   the number of labels for this channel
 * @param labels An array of labels.
 *
 * @deprecated New model has only a single 'label' per channel.
 * Use dr_txchannel_get_name()
 */
aud_error_t
dr_txchannel_get_txlabels
(
	const dr_txchannel_t * tx, // [IN]
	uint16_t * len,            // [IN/OUT]
	dr_txlabel_t * labels      // [OUT]
);

/**
 * Does the transmit channel have the given name as a canonical name
 * and / or as a label?
 *
 * @param tx the transmit channel
 * @param name the name to be checked against
 * @param txname_types a flag specifying whether the function should
 *   check the channels canonical name, labels or both. Legal values
 *   are DR_TXNAME_TYPE_CANONICAL, DR_TXNAME_TYPE_LABEL and
 *   DR_TXNAME_TYPE_ALL.
 *
 * @deprecated New model has only a single 'label' per channel.
 * Use dr_txchannel_get_name() or dr_txchannel_get_default_name()
 */
aud_bool_t
dr_txchannel_has_name
(
	const dr_txchannel_t * tx,
	const char * name,
	dante_txname_type_t txname_types
);

/**
 * Add a label 'name' to the given channel.
 *
 * @param tx the transmit channel
 * @param response_fn the function to be called upon completion of this operation
 * @param request_id A request identifier for this operation
 * @param name the label to be added to this channel
 * @param moveflags A flag indicating whether the label should be moved
 *   if it already exists on a different channel. Legal values are 0
 *   (don't move) and DR_MOVEFLAG_MOVE_EXISTING.
 *
 * @deprecated Use dr_txchannel_set_name()
 */
aud_error_t
dr_txchannel_add_txlabel
(
	dr_txchannel_t * tx,
	dr_device_response_fn * response_fn,
	dante_request_id_t * request_id,
	const char * name,
	dr_moveflag_t moveflags
);

/**
 * Replace the label 'old_name' with the label new_name on the given channel.
 *
 * @param tx the transmit channel
 * @param response_fn the function to be called upon completion of this operation
 * @param request_id A request identifier for this operation
 * @param old_name the old label name
 * @param new_name the new label name
 * @param moveflags A flag indicating whether the label should be moved
 *   if it already exists on a different channel. Legal values are 0
 *   (don't move) and DR_MOVEFLAG_MOVE_EXISTING.
 *
 * @deprecated Use dr_txchannel_set_name()
 */
aud_error_t
dr_txchannel_replace_txlabel
(
	dr_txchannel_t * tx,
	dr_device_response_fn * response_fn,
	dante_request_id_t * request_id,
	const char * old_name,
	const char * new_name,
	dr_moveflag_t moveflags
);

/**
 * Remove a label from the given channel
 *
 * @param tx the transmit channel
 * @param response_fn the function to be called upon completion of this operation
 * @param request_id A request identifier for this operation
 * @param name the name of the label to be removed from this channel
 *
 * @deprecated Use dr_txchannel_set_name()
 */
aud_error_t
dr_txchannel_remove_txlabel
(
	dr_txchannel_t * tx,
	dr_device_response_fn * response_fn,
	dante_request_id_t * request_id,
	const char * name
);

//----------------------------------------------------------
// TX Label functions
//----------------------------------------------------------

/**
 * Get a list of labels for an entire device.
 * On input, 'len' contains the length of the 'labels' array.
 * The function fills up to 'len' elements in the array 'labels'.
 * Afterwards, 'len' contains the number of active labels the device has.
 *
 * @param device the device object
 * @param len on input, the length of the 'labels' array, on output, the number of labels
 *  the device has.
 * @param labels an array that will be populated with the device's labels. If there are more
 *  labels than space in the array, only the available space is used.
 * 
 * @deprecated Use dr_txchannel_get_name()
 */
aud_error_t
dr_device_get_txlabels
(
	const dr_device_t * device, // [IN]
	uint16_t * len,             // [IN/OUT]
	dr_txlabel_t * labels       // [OUT]
);

/**
 * Get the transmit channel with the given canonical name or label
 *
 * @param device the device object
 * @param name the name or label of the channel of interest
 * @param txname_types A flag specifying which name types to consider,
 * in general this is will be 'DR_TXNAME_TYPE_ALL'
 *
 * @deprecated New model has only a single 'label' per channel.
 * Use dr_txchannel_get_name() or dr_txchannel_get_default_name()
 */
dr_txchannel_t *
dr_device_txchannel_with_name
(
	const dr_device_t * device,
	const char * name,
	dante_txname_type_t txname_types
);

/**
 * Mark a label as stale
 *
 * @param device the device object
 * @param label_id identifier of label to mark as stale
 *
 * @deprecated New model has only one default name per channel
 */
aud_error_t
dr_device_mark_txlabel_stale
(
	dr_device_t * device,
	dante_id_t label_id
);

/**
 * Get the TX label associated with an identifier
 *
 * @param device the device object
 * @param label_id identifier of label to get
 * @param label pointer to label data structure that will be populated if call succeeds
 *
 * @returns AUD_ERR_NOTFOUND if there is no label currently associated with the given id
 * @returns AUD_ERR_RANGE if the label id is greater than the maximum given by dr_device_max_txlabels
 *
 * @deprecated New model has only one default name per channel
 */
aud_error_t
dr_device_txlabel_with_id
(
	const dr_device_t * device, // [IN]
	dante_id_t label_id,        // [IN]
	dr_txlabel_t * label        // [OUT]
);

/**
 * Remove the TX label associated with an identifier
 *
 * Equivalent to doing dr_device_get_txlabel_by_id and then calling
 * dr_txchannel_remove_txlabel on the result.
 *
 * @param device the device object
 * @param response_fn the function to be called upon completion of this operation
 * @param request_id A request identifier for this operation
 * @param label_id identifier of label to remove
 *
 * @deprecated New model has only one default name per channel
 */
aud_error_t
dr_device_remove_txlabel_with_id
(
	dr_device_t * device,
	dr_device_response_fn * response_fn,
	dante_request_id_t * request_id,
	dante_id_t label_id
);


//----------------------------------------------------------
// RX flow templates
//----------------------------------------------------------

//-----------------------------------------
// Rx Channel information / configuration

/**
 * Does the device support receive templates? (older devices do not)
 *
 * @param device the device being queried
 *
 * @return AUD_TRUE if the device supports receive templates, AUD_FALSE otherwise
 *
 * @deprecated RX flow template configuration is no longer actively maintained
 */
aud_bool_t
dr_device_supports_rx_templates
(
	const dr_device_t * device
);

/** 
 * Get the id of the flow with which this flow has been associated.
 * If no flow has been associated with this channel then return 0
 * 
 * @param channel the receive channel
 *
 * @return The channel's associated flow, or NULL if no association
 *   has been made.
 *
 * @deprecated RX flow template configuration is no longer actively maintained
 */
dante_id_t
dr_rxchannel_get_associated_flow_id
(
	const dr_rxchannel_t * channel
);


//-----------------------------------------
// Rx flow user-configuration information

/**
 * Does the flow have a multicast template?
 *
 * @param flow the flow handle
 * @param is_multicast_template_ptr a pointer to a location to store the flow's 'multicast template' status
 *
 * @deprecated RX flow template configuration is no longer actively maintained
 */
aud_error_t
dr_rxflow_is_multicast_template
(
	dr_rxflow_t * flow,
	aud_bool_t * is_multicast_template_ptr
);

/**
 * Does the flow have a unicast template?
 *
 * @param flow the flow handle
 * @param is_unicast_template_ptr a pointer to a location to store the flow's 'unicast template' status
 *
 * @deprecated RX flow template configuration is no longer actively maintained
 */
aud_error_t
dr_rxflow_is_unicast_template
(
	dr_rxflow_t * flow,
	aud_bool_t * is_unicast_template_ptr
);


//-----------------------------------------
// Rx Flow template configuration

/**
 * Create a new unicast template configuration object for a flow
 * with the given id.
 *
 * This object is used to create a receive flow.  To modify an existing
 * active user-configured flow, use dr_rxflow_modify.
 *
 * @note If the id value is non-zero, the configuration will be applied to
 * the flow with the given id, overwriting any previous configuration for
 * that flow. A zero id is legal and means that the device should choose
 * an appropriate flow. If a existing flow already matches the given
 * configuration, no changes are made. Otherwise, the device searches for
 * an inactive slot to use. In no inactive slots are available, the call
 * fails. In any case, no existing flows will be changed. In general,
 * it is recommended that the host application choose an id to ensure that
 * the flow is created.
 *
 * @param device the device on which the flow is being configured
 * @param flow_id the id for this flow.
 * @param tx_device the name of the device from which the flow will
 *   receive audio.
 * @param num_slots the number of slots that this flow will have
 * @param config_ptr a pointer to the pointer that will hold the
 *   new configuration object.
 *
 * @deprecated RX flow template configuration is no longer actively maintained
 */
aud_error_t
dr_rxflow_config_new_unicast
(
	dr_device_t * device,
	dante_id_t flow_id,
	const char * tx_device,
	uint16_t num_slots,
	dr_rxflow_config_t ** config_ptr
);

/**
 * Does the config object describe a unicast template?
 *
 * @param config the configuration object
 *
 * @return AUD_TRUE if the config object describes a unicast template, AUD_FALSE otherwise
 *
 * @deprecated RX flow template configuration is no longer actively maintained
 */
aud_bool_t
dr_rxflow_config_is_unicast_template
(
	const dr_rxflow_config_t * config
);

/**
 * Create a new multicast template configuration object for a flow
 * with the given id.
 *
 * This object is used to create a receive flow.  To modify an existing
 * active user-configured flow, use dr_rxflow_modify.
 *
 * @note If the id value is non-zero, the configuration will be applied to
 * the flow with the given id, overwriting any previous configuration for
 * that flow. A zero id is legal and means that the device should choose
 * an appropriate flow. If a existing flow already matches the given
 * configuration, no changes are made. Otherwise, the device searches for
 * an inactive slot to use. In no inactive slots are available, the call
 * fails. In any case, no existing flows will be changed. In general,
 * it is recommended that the host application choose an id to ensure that
 * the flow is created.
 *
 * @param device the device on which the flow is being configured
 * @param flow_id the id for this flow.
 * @param tx_flow the name of the transmit flow from which the flow
 *   will receive audio,
 * @param tx_device the name of the device from which the flow will
 *   receive audio.
 * @param config_ptr a pointer to the pointer that will hold the
 *   new configuration object.
 *
 * @deprecated RX flow template configuration is no longer actively maintained
 */
aud_error_t
dr_rxflow_config_new_multicast
(
	dr_device_t * device,
	dante_id_t flow_id,
	const char * tx_device,
	const char * tx_flow,
	dr_rxflow_config_t ** config_ptr
);

/**
 * Does the config object describe a multicast template?
 *
 * @param config the configuration object
 *
 * @return AUD_TRUE if the config object describes a multicast template, AUD_FALSE otherwise
 *
 * @deprecated RX flow template configuration is no longer actively maintained
 */
aud_bool_t
dr_rxflow_config_is_multicast_template
(
	const dr_rxflow_config_t * config
);

/**
 * Add a channel to the list of channels that will be associated with the
 * given flow as part of the flow's initial configuration. Unicast flow
 * configurations allow a maximum of num_slots initial receive channel
 * associations as part of the initial configuration. Multicast flow
 * configurations allow an arbitrary number of channels to be added
 * (including multiple channels with the same subscription) but no more
 * than max_rx_flow_slots distinct subscriptions.
 *
 * @param config the configuration object
 * @param channel the channel to add to the configuration
 * @param tx_channel_name the transmit channel part of the receive
 *   channel's subscription
 *
 * @return AUD_SUCCESS if the channel was successfully added to the set
 *   of initial associations or an error otherwise.
 *
 * @deprecated RX flow template configuration is no longer actively maintained
 */
aud_error_t
dr_rxflow_config_add_associated_channel
(
	dr_rxflow_config_t * config,
	const dr_rxchannel_t * channel,
	const char * tx_channel_name
);

/**
 * Remove a channel from the list of channels that will be associated
 * with the flow as part of its initial configuration.
 * 
 * @param config the configuration object
 * @param channel the channel to add to the configuration
 *
 * @return AUD_SUCCESS if the channel was successfully removed from the
 *   set of initial associations or an error otherwise.
 *
 * @deprecated RX flow template configuration is no longer actively maintained
 */
aud_error_t
dr_rxflow_config_remove_associated_channel
(
	dr_rxflow_config_t * config,
	const dr_rxchannel_t * channel
);

/**
 * Get a receive flow configuration object that allows modifications to
 * associations for an existing flow. The config object contains an initially
 * empty set of associations to which the host application can add new associations.
 * A new set of associations overrides all old associations. Channels that were previously
 * associated but are not in the new set have their subscriptions and associations cleared.
 * Channels in both the old and new associations sets will have their subscription updated
 * if necessary. If the subscription is unchanged then audio will not be interrupted.
 * 
 * @note 'flow' must be a flow with an existing user-configured template.
 *   Dynamically-configured flows may not be modified.
 *
 * @param flow the flow to be modified
 * @param config_ptr a pointer to a location to hold the new config object
 *   pointer
 *
 * @return AUD_SUCCESS if a modification object was successfully obtained or
 *   an error otherwise.
 *
 * @deprecated RX flow template configuration is no longer actively maintained
 */
aud_error_t
dr_rxflow_replace_associations
(
	const dr_rxflow_t * flow,
	dr_rxflow_config_t ** config_ptr
);

/**
 * Get the initial subscription for the given channel that is part of the
 * initial association list for the flow.
 *
 * @param config the configuration object
 * @param channel the channel whose channel subscription is to be obtained.
 *
 * @return the subscription that will be given to the channel as part of
 *   its initial association, or NULL if the channel is not in the list
 *   of initial associations.
 *
 * @deprecated RX flow template configuration is no longer actively maintained
 */
const char *
dr_rxflow_config_get_associated_channel_subscription
(
	dr_rxflow_config_t * config,
	const dr_rxchannel_t * channel
);


//----------------------------------------------------------

#ifdef __cplusplus
}
#endif

#endif

/*
 * Copyright © 2024 Audinate Pty Ltd ACN 120 828 006 (Audinate). All rights reserved.
 */

